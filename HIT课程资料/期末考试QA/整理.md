# ● 计算机是xx位的？
指的是计算机CPU字的长度（字长）。 计算机中ALU的位数 = CPU中通用寄存器的位数 = 计算机的位数

# ● 常量表达式是谁来计算的？
编译器在编译阶段计算。

# ● 0与‘0’谁大?差多少?空间呢??
字符‘0’的ASCII码是48，则‘0’比0大，差48。
空间和声明的类型有关，如果0声明为int, ‘0’声明为char,则数字0占用的空间较大。

# ● 一个数的Float形式是唯一的吗？（除了0）
是，根据IEEE754标准，一个数字对应的格式是唯一的

# ● C语言中除以0一定报错溢出吗？
整数报错，浮点无穷大X/0>Y 可以

# ● 通用寄存器的通用是什么意思
因为通用寄存器既可用于传送和暂存数据，也可参与算术逻辑运算，并保存运算结果。

# ● CF与OF是什么关系？
CF针对无符号数(将寄存器中的操作数都看作是无符号数)

OF针对有符号数(将寄存器中的操作数都看作是有符号数)

# ● 计算机怎么判断两个数相加是否超出了范围？
CF位来判断无符号数运算的溢出，OF位来判断补码运算是否溢出。

# ● 32/64位的cpu中寄存器都是32/64位的？
不是，第三章最后提到的媒体寄存器是256位的，段寄存器（有的说32位，有的说16位）
CPU的字长 == 通用寄存器的位宽

# ● 一/二维数组采用什么寻址方式？
比例变址寻址

# ● 一个C生成的执行程序是多少位的是由谁来决定的？
（A）CPU （B）OS （C）编译器 （D）源程序           C

# ● int a[100]; 在作为全局变量、局部变量、参数时是怎么实现对a[i]元素的访问的？
全局变量：利用%rip+偏移量访问 

局部变量：利用%rbp+偏移量访问 

参数：先通过%rbp+偏移量得到栈中作为参数传递的a的首地址，然后利用此地址+偏移量访问

# ● 静态局部变量是怎么生成汇编语言的？
空间：全局区 赋初值：定义该变量的函数第一次被调用时 生命周期：整个源程序的周期

# ● 分析全局变量、局部变量、传值的参数的生命周期
静态全局变量：整个源程序的周期 

动态全局变量：整个源程序的周期 

静态局部变量：整个源程序的周期 

动态局部变量：定义它的函数的周期 传值的参数：定义它的函数的周期

# ● 简述缓冲器溢出的原理
缓冲区溢出，简单的说就是计算机对接收的输入数据没有进行有效的检测，向缓冲区内填充数据时超过了缓冲区本身的容量，而导致数据溢出到被分配空间之外的内存空间，使得溢出的数据覆盖了其他内存空间的数据。

# ● 怎么攻击缓冲器溢出的漏洞？
攻击原理（3个采分点）：向程序输入缓冲区写入特定的数据，例如在gets读入字符串时，使位于栈中的缓冲区数据溢出，用特定的内容覆盖栈中的内容，例如函数返回地址等，使得程序在读入字符串，结束函数gets从栈中读取返回地址时，错误地返回到特定的位置，执行特定的代码，达到攻击的目的。

# ● 怎么防范缓冲器溢出漏洞？
防范方法(2个采分点,有2个就算对)： 

1. 代码中避免溢出漏洞：例如使用限制字符串长度的库函数 

2. 随机栈偏移：程序启动后，在栈中分配随机数量的空间，将移动整个程序使用的栈空间地址 

3. 限制可执行代码的区域 

4. 进行栈破坏检查——金丝雀

# ● 结构体成员作为参数传输/返回是怎么实现的？
传递/返回结构体基地址+偏移量处的对应成员

# ● Y86-64的寻址方式有哪几种？
指令寻址方式： 顺序寻址方式 PC 跳跃寻址方式 jXX指令 

操作数寻址方式： 寄存器寻址 立即寻址 间接寻址 基址寻址

# ● 为什么用连接器？
链接器可以使得分离编译成为可能：我们可以把一个大的应用程序分解成许多小的，更好管理的模块，单独编译每一个模块。
在修改的时候，只用编译被修改的模块，重新链接就行。能节省大量时间。

# ● 有哪几种目标文件？怎么查看目标文件的各节信息？
目标文件：

可重定位目标文件：包含数据和代码，编译时多个可重定位目标文件生成可执行目标文件。

可执行目标文件：包含数据和代码，可以被直接加载运行。

共享目标文件：特殊的目标文件，可以在加载或运行时被动态的加载进内存并链接。(这个用于动态链接)

# ● 共享库的动态连接有哪几种方法？
加载时链接:当可执行文件首次加载和运行时进行动态链接

运行时链接:在程序开始运行后(通过编程指令)进行动态链接

# ● 编译器能做的程序员也通常采用的一般有用的优化有哪几种？

* 代码移动
  * 减少计算执行的频率
* 复杂运算简化
  * 用更简单的方法替换昂贵的操作
  * 移位、加，替代乘法/除法
  * 识别乘积的顺序
* 共享公用子表达式
  * 重用表达式的一部分
  * GCC 使用 –O1 选项实现这个优化
* 去掉不必要的过程调用
***

# ● 编译器优化的其他方法与策略？
* 减少函数调用
* 用临时/局部变量累计结果
* 避免每个循环的边界检查
* 使用指令级并行
***

# ● 简述现代超标量CPU的结构与执行程序特点
* 一个周期执行多条指令。
* 这些指令是从一个连续的指令流获取的，通常被动态调度的。
***

# ● x = (x OP d[i]) OP d[i+1] 与x = x OP (d[i] OP d[i+1])哪一个并行性好？
* x = x OP (d[i] OP d[i+1]) 的并行性更好
* 下一个循环的操作可以早一些开始，对之前的数据没有依赖。
***

# ● 存储访问局部性原理是什么意思？
程序倾向于使用距离最近用过的指令/数据地址相近或相等的指令/数据。

# ● Cache访问不命中的种类？
* 冷不命中（强制不命中）：当缓存为空时，对任何数据的请求都会不命中
* 冲突不命中：当缓存足够大，但是被引用的对象都映射到同一缓存块中，此种不命中称为冲突不命中
* 容量不命中：当工作集(working set)的大小超过缓存的大小时，会发生容量不命中
***

# ● 程序怎么利用高速缓存访问存储器？
程序会先到高速缓存中寻找所需数据。如果能够找到，直接从高速缓存中调用，不再访问内存。当cache中对应位置为空时，发生冷不命中，将从下一级存储中寻找数据并将其放入本级存储。当对应位置不为空但标记位不同是，发生冲突不命中，将从下一级存储中寻找数据并替换此处数据。

# ● 为什么用中间位不用高位作为组/索引？
* 如果用高位做索引，连续的存储器块会映射到相同的高速缓存块中，具有良好空间局部性的程序顺序扫描一个数组的元素时，高速缓存总保存着一个块大小的数组原内容，高速缓存使用的效率很低。
* 用中间为作为组索引，相邻的块总是映射到不同的高速缓存行，提高高速缓存的效率。
***

# ● 全相联Cache有冲突不命中吗？为什么
* 全相连Cache没有冲突不命中，只有容量不命中
* 下一级存储器中的数据可对应本级cache中的任意一行，当本级cache未装满时，数据将被装入空白的行，而不会选择替换别的行。
***

# ● 为什么高速缓存用不命中率而不是命中率来衡量性能？
* 命中率相差较少时，实际性能相差很多。
* 命中率为97%和99%的性能可相差两倍。
***

# ● 重新排列以提升程序的_局部性
重新排列以提升程序的 * 空间 * 局部性

# ● 使用分块以提升程序的_局部性
使用块来提高 * 时间 * 局部性

# ● 进程状态有哪几种？进程终止有几种方法？
 * linux上进程有5种状态:  *
* 运行(正在运行或在运行队列中等待)
* 中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号)
* 不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生)
* 僵死(进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放)
* 停止(进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行)

* 进程终止有8种 *

正常终止五种：

1.从main返回。 

2.调用exit。 

3.调用exit或Exit。 

4.最后一个线程从其启动例程返回。 

5.最后一个线程调用pthread_exit。 

* 三种异常终止： *

6.调用abort()。 

7.接到一个信号并终止。 

8.最后一个线程对取消请求作出响应。

# ● fork的子进程与其父进程同名的全局变量对应同一物理地址？
- fork时子进程获得父进程数据空间、堆和栈的复制，所以变量的地址（当然是虚拟地址）也是一样的。
- 每个进程都有自己的虚拟地址空间，不同进程的相同的虚拟地址显然可以对应不同的物理地址。因此地址相同（虚拟地址）而值不同没什么奇怪。

fork子进程完全复制父进程的栈空间，也复制了页表，但没有复制物理页面，所以这时虚拟地址相同，物理地址也相同，但是会把父子共享的页面标记为“只读”，如果父子进程一直对这个页面是同一个页面，知道其中任何一个进程要对共享的页面“写操作”，这时内核会复制一个物理页面给这个进程使用，同时修改页表。而把原来的只读页面标记为“可写”，留给另外一个进程使用。

假定父进程malloc的指针指向0x12345678, fork 后，子进程中的指针也是指向0x12345678，但是这两个地址都是虚拟内存地址 （virtual memory)，经过内存地址转换后所对应的 物理地址是不一样的。所以两个进城中的这两个地址相互之间没有任何关系。



就是说：

**子进程继承父进程的全局变量。**

 **子进程创建以后，可以读取原来父进程的全局变量的值。**

 **但是创建以后，子进程修改了变量，或者是父进程修改了变量值，互相都不影响了。** 



**无论是什么类型的变量，fork后父子进程中都是一样的，但两者之间没有关系，任何一个进程修改变量后，在另一个进程中都不能知道，更不能访问另一个进程中的变量，也不会对应相同的物理地址了**

# ● 信号与异常的区别与联系
1.异常

定义：异常就是控制流中的突变，用来响应处理器状态的某些变化

2.信号

定义：信号是一条小消息，通知进程系统中发生了一个某种类型的时间

区别

信号是软件上的概念，指的是由内核 产生，并由用户态程序响应的事件。

异常是硬件上的概念，指的是 CPU 因执行某些指令而产生的事件，比如常见的除零错误。另外，相对于中断，异常是同步的，中断是异步的；异常是由执行指令产生的，中断则是由硬件产生的。

信号是异步的进程间通讯机制,是在软件层次上对中断机制的一种模拟

联系

1.硬件异常也能产生信号，例如被零除、无效内存引用等。这些条件通常先由内核硬件检测到，然后通知内核。内核将决定产生什么样的信号。

# ● MMU怎么分配一个新的页面（VM/PM/PTE）？
当操作系统分配一个新的虚拟内存页时，调用malloc的结果。分配过程即为在磁盘上创建空间并更新PTE中对应的页表，使它指向磁盘上这个新创建的页面

# ● 多个进程的PTE项目可能存储同一内容?
多个虚拟地址可能映射同一个物理地址，所以可能储存同一内容

# ● TLB的Block是什么内容？
PPN（物理页号）